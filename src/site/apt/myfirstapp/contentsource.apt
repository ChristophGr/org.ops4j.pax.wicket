    ------------------------
    Writing Content services
    ------------------------
    Niclas Hedhman
    ------------------------
    2006 June 1
    ------------------------

Writing the Content Source

    <ContentSource> is a model of a Wicket component hierachy, which is resolved at request time. The <ContentSource>
    is registered into the OSGi framework as services, and <ContentAggregator>s will monitor such registration and
    <wire> the <ContentSource> when the <AggregationMatchExpression> of the <ContentSource> matches the
    <AggregationPoint> of the <ContentAggregator>. At request time, the <ContentMatchExpression> will also be matched
    against the <ContentId> being processed, and if a match is found, the <<<createComponent()>>> of the <ContentSource>
    is called.


    Franchisee is a tenant in the department store. And this bundle retrieves all the franchisees from the business
    model, and wire them to the floor they are located on.

        * <<<FranchiseeContent>>> is the model of the view for a individual <<<Franchisee>>>. It is a subclass of
          AbstractContentSource, and unlike the <<<FloorAggregatedSource>>>, this only implements the <ContentSource>
          interface, as the <<<Franchisee>>> does not have any children Components of any kind.

        * FranchiseePanel is utilizing an Ajax feature in Wicket, which allows for editing of the labels directly in
          its rendering position, simply by clicking on it.

        * The <<<Activator>>> just ask the business model for all the floors and all tenants on each floor, and does
          the <wiring> required.

        []

    We need an Activator;

+------------------------------
public class Activator
    implements BundleActivator
{
    private List<ServiceRegistration> m_registrations;

    public void start( BundleContext bundleContext )
        throws Exception
    {
        m_registrations = new ArrayList<ServiceRegistration>();
        String depStore = DepartmentStore.class.getName();
        ServiceReference depStoreService = bundleContext.getServiceReference( depStore );
        DepartmentStore departmentStore = (DepartmentStore) bundleContext.getService( depStoreService );

        m_registrations = new ArrayList<ServiceRegistration>();
        List<Floor> floors = departmentStore.getFloors();
        for( Floor floor: floors )
        {
            List<Franchisee> franchisees = floor.getFranchisees();
            for( Franchisee franchisee : franchisees )
            {
                String destinationId = floor.getName() + ".franchisee";
                FranchiseeContentSource source = new FranchiseeContentSource( bundleContext, franchisee, "departmentstore"  );
                source.setDestinationId( destinationId );
                ServiceRegistration registration = source.register();
                m_registrations.add( registration );
            }
        }
    }

    public void stop( BundleContext bundleContext )
        throws Exception
    {
        for( ServiceRegistration registeration : m_registrations )
        {
            registeration.unregister();
        }
        m_registrations.clear();
    }
}
+------------------------------

    In this sample, the business logic sits in a separate department store model bundle, and the component knows
    how to extract the available Franchisees, and which floor they are located on. A more generic approach is to
    set the <Destination> to <<<ContentSource.DESTINATION_UNKNOWN>>> and let a separate bundle figure out the
    wiring. We will probably come up with various strategies around this in the future.

    We need to create a <ContentSource> class, which we subclass from the <AbstractContentSource> to save us a lot of
    work. For the Franchisee it looks like;

+------------------------------
public class FranchiseeContentSource extends AbstractContentSource<FranchiseePanel>
{

    private Franchisee m_franchisee;

    public FranchiseeContentSource( BundleContext context, Franchisee franchisee, String applicationName )
    {
        super( context, franchisee.getName(), applicationName );
        m_franchisee = franchisee;
    }

    protected FranchiseePanel createComponent( String id, Component parent )
    {
        return new FranchiseePanel( id, m_franchisee );
    }
}
+------------------------------

    Nothing much to do here, just instantiate the Wicket component on demand.

    Next, we need the Wicket part of our content, i.e. the FranchiseePanel created in the <<<createComponent()>>>
    method call above.

+------------------------------
public class FranchiseePanel extends Panel
    implements Serializable
{

    private static final long serialVersionUID = 1L;

    private static final String WICKET_ID_NAME_LABEL = "name";
    private static final String WICKET_ID_DESC_LABEL = "description";

    public FranchiseePanel( String id, Franchisee franchisee )
    {
        super( id );

        AjaxEditableLabel nameLabel = new AjaxEditableLabel( WICKET_ID_NAME_LABEL, new PropertyModel( franchisee, "name") );
        add( nameLabel );

        AjaxEditableLabel descLabel = new AjaxEditableLabel( WICKET_ID_DESC_LABEL, new PropertyModel( franchisee, "description") );
        add( descLabel );
    }
}
+------------------------------

    This is standard Wicket stuff. It is provided a Franchisee from the business logic model, and adds two Wicket
    Labels. This must correspond to an HTML snippet;

+------------------------------
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:wicket="http://wicket.sourceforge.net/" xml:lang="en" lang="en">
<body>
    <wicket:panel>
        <span class="name" wicket:id="name"></span>
        <span class="description" wicket:id="description"></span>
    </wicket:panel>
</body>
</html>
+------------------------------

    For those who are not vivid Wicket users (like myself), it is <<important>> that the \<span\> element contains
    an opening and closing tag, instead of the common <span ... /> format. I am not sure why Wicket makes this
    distinction, but without it the correct code will not be generated.

Bundle Manifest

    We need a bundle manifest for the above code, which needs to look like this;

+------------------------------
Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: Franchisee Plug-in
Bundle-SymbolicName: org.ops4j.pax.wicket.sample.departmentstore.franchisee
Bundle-Version: 1.0.0
Bundle-Vendor: OPS4J
Bundle-Localization: plugin
Bundle-Activator: org.ops4j.pax.wicket.samples.departmentstore.view.franchisee.internal.Activator
Import-Package: org.ops4j.pax.wicket.samples.departmentstore.model;version="[1.0.0,1.1.0)",
 org.ops4j.pax.wicket.util;version="[1.0.0,1.1.0)",
 org.osgi.framework;version="[1.3.0,2.0.0)",
 org.osgi.service.cm;version="[1.2.0,2.0.0)",
 wicket;version="[1.2.0,1.3.0)",
 wicket.extensions.ajax.markup.html;version="[1.2.0,1.3.0)",
 wicket.markup.html.basic;version="[1.2.0,1.3.0)",
 wicket.markup.html.panel;version="[1.2.0,1.3.0)",
 wicket.model;version="[1.2.0,1.3.0)"
+------------------------------

    The important parts to notice are;
    * No exports !
    * Import the Pax Wicket Service package.
    * Import the used Wicket packages.
    * Import the OSGi framework.
    * If you need logging, import Pax Logging.

Conclusion

    In essence, this concludes what we need to know about writing <ContentSource> services. We have seen that it is
    not very hard, and you will see that most of your issues will be ordinary Wicket stuff, i.e. getting the
    hierarchies right, which is not related to Pax Wicket Service at all.

