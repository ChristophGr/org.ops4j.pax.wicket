    -------------------
    Pax Wicket Concepts
    -------------------
    Niclas Hedhman
    -------------------
    2006 June 2
    -------------------

Concepts & API classes.

    * <<<AbstractAggregatedSource>>>
    
      The <AbstractAggregatedSource> is an implementation of both the <ContentSource> and the <ContentAggregator>
      interfaces, making it suitable for panels, tables and other types of aggregation where the resulting aggregation
      is likely to be part of a larger aggregation, for instance on a Page.

    * <<<AbstractContentSource>>>

      This is a implementation of the <ContentSource> interface, suitable for most content that are leaves in the model.
      A single method, <<<protected abstract <T extends Component> E createComponent( String contentId, T parent )>>>,
      needs to be implemented.


    * <<<AbstractPageFactory>>>

      This is an implementation of the <PageFactory> interface, handling the OSGi registration of the pages and
      handling the <<<ManagedService>>> interface, but leaving the <<<getPageClass()>>> and  <<<createPage()>>> to be
      implemented by the subclass.

    * <AggregationMatchExpression>

      <AggregationMatchExpression> is the first part of the <Destination>, i.e. what is to the left of the dot in the
      more formal \<<AggregationMatchExpression>\><<.>>\<<ContentMatchExpression>\>. The <AggregationMatchExpression> of
      the <Destination> of <ContentSource>s is matched against <AggregationPoint>s to determine if a <wire> should be established between
      the <AggregationPoint> and the <ContentSource>.

    * <AggregationPoint>

      AggregationPoint is an <extension point> to which ContentSource can be
      attached. Each AggregationPoint may have many ContentIDs defined to be populated. The
      AggregationPoint is identified by a AggregationID which must be unique within the OSGi
      runtime platform.

    * <ApplicationName>

      All services that are part of a Pax Wicket application, must have the application name property set in its service
      registration. The application name key is available in <<<ContentSource.APPLICATION_NAME>>>. Failure to set
      this will preclude the service to become part of the Pax Wicket application.

    * <ContentAggregator>

      The OSGi service that has been registered with a AggregationID and
      implements the ContentAggregator interface. ContentAggregators look for DestinationIDs that
      <<matches>> the AggregationID defined for the ContentAggregator.

    * <ContentId>

      Each AggregationPoint defines zero, one or more <ContentId>s. The <ContentId> defines which subpart of an
      <AggregationPoint> that a <ContentSource> is the provider for. In reality, the <ContentId> is the <<wicket:id>>
      found in the html and will be requested by Wicket to Pax Wicket to supply components for. Pax Wicket monitors the
      OSGi services to determine the <wiring> of the <ContentSource>s to the <ContentAggregator>s, and at request time
      the <ContentAggregator> will request component creation from the <wired ContentSource> for each of the
      <ContentId>s (i.e. wicket:id).

    * <ContentMatchExpression>

      <ContentMatchExpression> is the second part of the <Destination>, i.e. what is to the right of the dot in the
      more formal \<<AggregationMatchExpression>\><<.>>\<<ContentMatchExpression>\>. The <ContentMatchExpression> of
      the <Destination> of <ContentSource>s is matched against <ContentId>s to determine if a <wire> should be used
      during the request cycle to create the content from the <ContentSource>. Only <ContentSource>s that are <wired>
      to the <AggregationPoint> and that has a matching <ContentMatchExpression> of the <ContentId> being processed will
      have its <<<createComponent()>>> method called.

    * <ContentSource>

      Any Wicket component can be packaged into a <ContentSource>. <ContentSource> is a
      OSGi service that gets registered into the OSGi framework. <ContentSource>s are written by the
      developer, but there are extensive support in the Pax Wicket Service to make this task really
      simple.

    * <Destination>

      Each <ContentSource> service must in <<runtime>> define a <Destination>. The
      <Destination> consists of two parts. The first part is  which <AggregationPoint> should the <ContentSource> be
      bound to, and the second part is the <ContentId> within that <AggregationPoint> that the ContentSource will
      provide for.

    * Model vs Components

      In Pax Wicket, you create a <<Model>> of the view, whereas in Wicket itself you create the Components of the view
      directly. This is important to understand, as Pax Wicket needs to delay the creation of Components as long as
      possible, yet have a clear understanding of how things are hanging together.

      The interfaces in Pax Wicket descibes that model, and there are suitable default implementations available to make
      it easy to create a model of the view, and instantiating the view from these model parts.

    * <PageFactory>

      Pages also need to be modelled, and the main challange reside in bookmarkable pages in Wicket, where Wicket will
      do the instantiation. PageFactory is a model part, which allows the developer control over the instantiation
      of pages, by implementing the <<<getPageClass()>>> and <<<createPage()>>> methods.

    * <<<RootContentAggregator>>>

      The <RootContentAggregator> is an implementation of the <ContentAggregator> suitable for aggregating panels
      and other components as a model for a Wicket page. Unlike the <AbstractContentAggregator>, this implementation
      does not implement  the <ContentSource> interface, and can therefor not be further aggregated in higher level
      <ContentAggregators>.

    * <Wiring>, <Wired>

      <Wiring> is the process of connecting a <ContentSource> to a <ContentAggregator>. The <ContentAggregator> publishes
      an <AggregationPoint> (available from <<<ContentSource.AGGREGATION_POINT>>>) and the <ContentSource> publishes a
      <Destination> (available from <<<ContentSource.DESTINATION>>>). The <Destination> consists of two parts, dot separated,
      as \<<AggregationMatchExpression>\>.\<<ContentMatchExpression>\> where the <ContentSource> will be <wired> to the <ContentAggregator> that
      publishes the <AggregationPoint> that is present in the <Destination>,  and the <ContentAggregator> will lookup
      the <ContentId> from its children during component creation in the request cycle.

