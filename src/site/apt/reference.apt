        ------------------
        Pax Wicket Service
        ------------------
        Niclas Hedhman
        ------------------
        2006 May 31
        ------------------

    The Pax Wicket Service is an OSGi service for supporting the creation of Wicket applications
    running on the OSGi platform.

    The Pax Wicket Service allows you to load and unload Wicket pages and page content in runtime.
    It also allows you to register new Wicket Applications in runtime. All this without restarting
    the application as a whole.

Architecture

    The basic architecture of the Pax Wicket eco system, is to make things smaller, runtime
    replaceable and a strict separation of concerns. We do that by leveraging the service layer in
    OSGi together with runtime wiring through the Config Admin service.

    This will, as we shall see, allow us to break up the application in almost arbitrary bundles,
    and yet get a coherent view served by Wicket. One way to look at the architecture is the bundle
    break down. It looks like this;

+-----------------------------
 +-----------------+  +------------+   +-------------+   +-----------+   +-----------+   +-------------+
 | HTTP Service    |  | Pax Wicket |   |  Bus Logic  |   | Component |   |   Page    |   | Application |
 | (Standard OSGi) |  |   Service  |   |  bundle(s)  |   | bundle(s) |   | bundle(s) |   |  bundle(s)  |
 +-----      ------+  +---      ---+   +---      ----+   +--      ---+   +---      --+   +---      ----+
       \    /             \    /           \    /           \    /           \    /          \    /
 +----- \  / ------------- \  / ----------- \  / ----------- \  / ----------- \  / ---------- \  / ----+
 |     \ \/ /             \ \/ /           \ \/ /           \ \/ /           \ \/ /          \ \/ /    |
 |      \  /               \  /             \  /             \  /             \  /            \  /     |
 |       \/                 \/               \/               \/               \/              \/      |
 |                                                                                                     |
 |                                           OSGi Runtime Platform                                     |
 +-----------------------------------------------------------------------------------------------------+
+-----------------------------

    However, this is not very useful to get an understanding on how things really hang together.
    Let's start exploring the various aspects of the Pax Wicket Service architecture.

ContentSource, ContentAggregator and Component

    First we need to introduce a couple of concepts.

    * ContentSource - Any Wicket component can be packaged into a ContentSource. ContentSource is a
      OSGi service that gets registered into the OSGi framework. ContentSources are written by the
      developer, but there are extensive support in the Pax Wicket Service to make this task really
      simple.

    * Destination - Each ContentSource service must in <<runtime>> define a Destination. The
      Destination is described in a DestinationID which consists of two parts. The first part is
      which Containment point should the Content be bound to, and the second part of the
      DestinationID is the wicket:id within that Containment.

    * AggregationPoint - AggregationPoint is an <extension point> to which ContentSource can be
      attached. Each AggregationPoint may have many ContentIDs defined to be populated. The
      AggregationPoint is identified by a AggregationID which must be unique within the OSGi
      runtime platform.

    * ContentAggregator - The OSGi service that has been registered with a AggregationID and
      implements the ContentAggregator interface. ContentAggregators look for DestinationIDs that
      <<matches>> the AggregationID defined for the ContentAggregator.

    So, let's look at the primary interfaces of Content and ContentContainer.

+-----------------------------
package org.ops4j.pax.wicket.service;

import wicket.Component;

public interface Content
{

    String MOUNTPOINT = "pax.wicket.mountpoint";

    String APPLICATION_NAME = "pax.wicket.applicationname";

    String DESTINATIONID = "pax.wicket.destinationid";

    String DESTINATIONID_UNKNOWN = "";

    String PAGE_NAME = "pax.wicket.pagename";

    String PAGE_ID = "pax.wicket.pageid";

    String CONTENTID = "pax.wicket.contentid";

    String CONTAINMENTID = "pax.wicket.containmentid";

    String DEPLOYMENT_MODE = "pax.wicket.deploymentmode";

    String HOMEPAGE_CLASSNAME = "pax.wicket.homepage.classname";

    String getDestinationId();

    Component createComponent();

}
+-----------------------------

+------------------------------
package org.ops4j.pax.wicket.service;

import wicket.Component;
import java.util.List;

public interface ContentContainer
{

    String getContainmentId();

    List<Component> createComponents( String id );

    void dispose();
}
+------------------------------

    As you see, there is not much in these interfaces, and that can seem very strange at first. The
    issue is that quite a lot of the semantics of the Content and ContentContainer are in the
    behavior and interaction with the OSGi framework, which is not expressed in the interfaces.

    * ContentSource must be registered as OSGi service, and must have a unique
      org.osgi.framework.Constants.SERVICE_PID set.

    * ContentAggregator must listen for ContentSource service registrations in the OSGi framework.

    * ContentAggregator must keep track of which ContentSource service have a DestionationID that
      matches its own AggregationID.

    * ContentAggregators must delegate the createComponents() method to the ContentSources that are
      wired to each of the ContentIDs defined.


    Since we expect all this work to be fairly standard, we have provided some implementations of
    these interfaces, that should be sufficient for most usages.

    * AbstractContentSource

    * DefaultAggregator

    *

    By using these, there is very little overhead that the developer needs to deal with (see
    <Writing ContentSource services> and <Writing ContentAggregator services> below).


Pages

    Pages are registered into the OSGi framework as services bound to the same
    Content.APPLICATION_NAME property value as all other parts. Pages must implement the
    PageContent interface.

+---------------------------------
package org.ops4j.pax.wicket.service;

import wicket.Page;
import wicket.PageParameters;

public interface PageContent
{

    Class<? extends Page> getPageClass();

    Page createPage( PageParameters params );

}
+---------------------------------

Pax Wicket Applications

    Pax Wicket Service supports many Pax Wicket applications being deployed simultaneously onto the
    same instance of Pax Wicket Service. For each Pax Wicket application, a separate Servlet will
    be created and mounted on to a configurable mount point in the URL space. However, care must be
    taken to ensure that all ContainmentIDs are registered under unique names.

    All Pax Wicket applications are also wired together based on the Content.APPLICATION_NAME
    property value in its OSGi service registration. All services that are part of the Pax Wicket
    application must share the same name and properly register it as a service property.


Authentication

    Pax Wicket is supporting the Wicket authentication framework through and users can either be
    authenticated through the standard OSGi User Admin service, or by a user supplied
    PaxWicketAuthenticator implementation.

+---------------------------------

package org.ops4j.pax.wicket.service;

import wicket.authorization.strategies.role.Roles;

public interface PaxWicketAuthenticator
{

    String USERNAME_IDENTITY = "pax.wicket.authen.id.username";

    String CREDENTIALS_PASSWORD = "pax.wicket.auten.cred.password";

    Roles authenticate( String username, String password );

}

+---------------------------------

