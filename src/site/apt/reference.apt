        ------------------
        Pax Wicket Service
        ------------------
        Niclas Hedhman
        ------------------
        2006 May 31
        ------------------

    The Pax Wicket Service is an OSGi service for supporting the creation of Wicket applications
    running on the OSGi platform.

    The Pax Wicket Service allows you to load and unload Wicket pages and page content in runtime.
    It also allows you to register new Wicket Applications in runtime. All this without restarting
    the application as a whole.

Architecture

    The basic architecture of the Pax Wicket eco system, is to make things smaller, runtime
    replaceable and a strict separation of concerns. We do that by leveraging the service layer in
    OSGi together with runtime wiring through the Config Admin service.

    This will, as we shall see, allow us to break up the application in almost arbitrary bundles,
    and yet get a coherent view served by Wicket. One way to look at the architecture is the bundle
    break down. It looks like this;

[images/Architecture.png] Pax Wicket Architecture

    However, this is not very useful to get an understanding on how things really hang together.
    Let's start exploring the various aspects of the Pax Wicket Service architecture.

ContentSource, ContentAggregator and Component

    It is important to keep the {{{concepts.html}concepts page}} readily available. To recap some
    of the information from that page;

    * <<ContentSource>> - Any Wicket component can be packaged into a <ContentSource>. <ContentSource> is a
      OSGi service that gets registered into the OSGi framework. <ContentSource>s are written by the
      developer, but there are extensive support in the Pax Wicket Service to make this task really
      simple.

    * <<Destination>> - Each <ContentSource> service must in <<runtime>> define a <Destination>. The
      <Destination> consists of two parts. The first part is which <AggregationPoint> the <ContentSource> should be
      bound to, and the second part of the <Destination> is the <ContentId> within that <AggregationPoint>.

    * <<AggregationPoint>> - <AggregationPoint> is a kind of a extension point to which <ContentSource> can be
      attached. Each <AggregationPoint> may have many <ContentIDs> defined to be populated.

    * <<ContentAggregator>> - The OSGi service that has been registered with a AggregationID and
      implements the ContentAggregator interface. ContentAggregators look for DestinationIDs that
      <<matches>> the AggregationID defined for the ContentAggregator.

    So, let's look at the primary interfaces of
    {{{http://scm.ops4j.org/repos/ops4j/qa/projects/pax/wicket-0.4.0/service/src/main/java/org/ops4j/pax/wicket/api/ContentSource.java}ContentSource}}
    and
    {{{http://scm.ops4j.org/repos/ops4j/qa/projects/pax/wicket-0.4.0/service/src/main/java/org/ops4j/pax/wicket/api/ContentAggregator.java}ContentAggregator}}
    .

    As you see, there is not much in these interfaces, and that can seem very strange at first. The
    issue is that quite a lot of the semantics of the ContentSource and ContentAggregator are in the
    behavior and interaction with the OSGi framework, which is not expressed in the interfaces.

    * <ContentSource> must be registered as an OSGi service, and must have a unique
      <<<org.osgi.framework.Constants.SERVICE_PID>>> set.

    * <ContentAggregator> must listen for <ContentSource> service registrations in the OSGi framework.

    * <ContentAggregator> must keep track of which <ContentSource> service have a <Destination> that
      matches its own <AggregationPoint>. Such much is said that it <wires> the <ContentSource> to the
      <ContentAggregator>.

    * <ContentAggregator>s must delegate the createComponents() method to the <ContentSource>s that are
      <wired> to each of the <ContentId>s defined.


    Since we expect all this work to be fairly standard, we have provided some implementations of
    these interfaces, that should be sufficient for most usages. You find these in the
    <<<org.ops4j.pax.wicket.util>>> package;

    * AbstractContentAggregator

      The AbstractContentAggregator is your typical superclass of a <ContentAggregator>. By extending
      this class, you need to provide the implementation for <<<protected abstract <T extends Component> E createComponent( String contentId, T parent )>>>.
      The
      The parent is passed as a preparation for Wicket 2.0, and Pax Wicket will support Wicket 2.0 as soon as
      it is released.

    * DefaultContentSource

    * RootContentAggregator

    By using these, there is very little overhead that the developer needs to deal with (see
    <Writing ContentSource services> and <Writing ContentAggregator services>).


Pages

    Pages are registered into the OSGi framework as services bound to the same
    <<<Content.APPLICATION_NAME>>> property value as all other parts. Pages are defined via a <PageController> instance,
    which allows for the page to be bookmarkable. The
    {{{http://scm.ops4j.org/repos/ops4j/qa/projects/pax/wicket-0.4.0/service/src/main/java/org/ops4j/pax/wicket/api/PageController.java}PageController}} interface
    is fairly simple, and the packaging of the page related resources should go into the same bundle or bundle fragment,
    and Pax Wicket will resolve the classloading for those.

Pax Wicket Applications

    Pax Wicket Service supports many Pax Wicket applications being deployed simultaneously onto the
    same instance of Pax Wicket Service. For each Pax Wicket application, a separate Servlet will
    be created and mounted on to a configurable mount point in the URL space. Also, for each Pax Wicket Application
    a new instance of Wicket will be created, and no sharing across those instance will occur.

    All Pax Wicket applications are also wired together based on the <<<Content.APPLICATION_NAME>>>
    property value in the OSGi service registrations. All services that are part of the Pax Wicket
    application must share the same name and properly register it as a service property.

Authentication

    Pax Wicket is supporting the Wicket authentication framework through and users can either be
    authenticated through the standard OSGi User Admin service, or by a user supplied
    PaxWicketAuthenticator implementation. More about that in a separate section.

