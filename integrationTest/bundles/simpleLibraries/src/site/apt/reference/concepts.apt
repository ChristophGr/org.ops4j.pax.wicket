    -------------------
    Pax Wicket Concepts
    -------------------
    Niclas Hedhman
    -------------------
    2006 June 2
    -------------------

Concepts & API classes.

    * <<<AbstractAggregatedSource>>>
    
      The <AbstractAggregatedSource> is an implementation of both the <ContentSource> and the <ContentAggregator>
      interfaces, making it suitable for panels, tables and other types of aggregation where the resulting aggregation
      is likely to be part of a larger aggregation, for instance on a Page.

    * <<<AbstractContentSource>>>

      This is a implementation of the <ContentSource> interface, suitable for most content that are leaves in the model.
      A single method, <<<protected abstract <T extends Component> E createComponent( String contentId )>>>,
      needs to be implemented.


    * <<<AbstractPageFactory>>>

      This is an implementation of the <PageFactory> interface, handling the OSGi registration of the pages and
      handling the <<<ManagedService>>> interface, but leaving the <<<getPageClass()>>> and  <<<createPage()>>> to be
      implemented by the subclass.

    * <Aggregation>

      With Wicket, each component is tied to it's parent at compile time. Extendable systems,though, need 
      to accommodate for future changes, which is where Pax Wicket comes into play.
      Pax Wicket allows the decoupling of
      components from parents for dynamic use in an OSGi environment.
      With Pax Wicket, that certain aggregation containers don't know what kind of content
      they will be holding until much later in the development cycle no longer becomes an issue. 
      <Aggregation> is the key concept to accomplish this.
      <Aggregation> is the runtime process where the <ContentSource> instances "found" in the OSGi framework
      are wired into the available
      <AggregationPoint>s. It is resolved in the request cycle, and through the classloading capabilities in
      OSGi it is possible to change the <ContentSource> instance wired to an <AggregationPoint> at runtime. This
      includes the moving of a <ContentSource> to another <AggregationPoint> as well as replacing it with a newer
      version of itself. Pretty cool, huh?

    * <AggregationMatchExpression>

      <AggregationMatchExpression> is the first part of the <Destination>, i.e. what is to the left of the dot in the
      more formal \<<AggregationMatchExpression>\><<.>>\<<ContentMatchExpression>\>. The <AggregationMatchExpression> of
      the <Destination> of <ContentSource>s is matched against <AggregationPoint>s to determine if a <wire> 
      should be established between the <AggregationPoint> and the <ContentSource>.

    * <AggregationPoint>

      AggregationPoint is an <extension point> to which <ContentSource> can be
      attached. Each AggregationPoint may have many ContentIDs defined to be populated. The
      AggregationPoint is identified by a AggregationID which must be unique within the OSGi
      runtime platform.

    * <Application>

      A Pax Wicket <Application> is the unit that collaborates within a single Wicket instance. For each
      <<<PaxWicketApplicationFactory>>> created, one full Wicket instance will also be created. The use of
      <Application>s should be kept to a minimum, and typically only a single one should exist for an 
      OSGi framework. However, when required, through proper use of the <ApplicationName>, Pax Wicket 
      is capable of supporting many <Application>s simultaneously.
      Each <Application> must have unique <ApplicationName> and a single PaxWicketApplicationFactory
      created.

    * <ApplicationName>

      All services that are part of a Pax Wicket application, must have the application name property set in its service
      registration. The application name key is available in <<<ContentSource.APPLICATION_NAME>>>. Failure to set
      this will preclude the service to become part of the Pax Wicket application.

    * <Content>

      <Content> is the old name for <ContentSource> and is still used incorrectly. It should not be a concept
      or definition item at all, and instead refer to any content, such as html, css and java generated content.
      
    * <ContentAggregator>

      The OSGi service that has been registered with a AggregationID and
      implements the ContentAggregator interface. ContentAggregators look for DestinationIDs that
      <<matches>> the AggregationID defined for the ContentAggregator.

    * <ContentId>

      Each AggregationPoint defines zero, one or more <ContentId>s. The <ContentId> defines which subpart of an
      <AggregationPoint> that a <ContentSource> is the provider for. In reality, the <ContentId> is the <<wicket:id>>
      found in the html and will be requested by Wicket to Pax Wicket to supply components for. Pax Wicket monitors the
      OSGi services to determine the <wiring> of the <ContentSource>s to the <ContentAggregator>s, and at request time
      the <ContentAggregator> will request component creation from the <wired ContentSource> for each of the
      <ContentId>s (i.e. wicket:id).

    * <ContentMatchExpression>

      <ContentMatchExpression> is the second part of the <Destination>, i.e. what is to the right of the dot in the
      more formal \<<AggregationMatchExpression>\><<.>>\<<ContentMatchExpression>\>. The <ContentMatchExpression> of
      the <Destination> of <ContentSource>s is matched against <ContentId>s to determine if a <wire> should be used
      during the request cycle to create the content from the <ContentSource>. Only <ContentSource>s that are <wired>
      to the <AggregationPoint> and that has a matching <ContentMatchExpression> of the <ContentId> being processed will
      have its <<<createComponent()>>> method called.

    * <ContentSource>

      Any Wicket component can be packaged into a <ContentSource>. <ContentSource> is a
      OSGi service that gets registered into the OSGi framework. <ContentSource>s are written by the
      developer, but there are extensive support in the Pax Wicket Service to make this task really
      simple.

    * <Destination>

      Each <ContentSource> service must in <<runtime>> define a <Destination>. The
      <Destination> consists of two parts. The first part is  which <AggregationPoint> should the <ContentSource> be
      bound to, and the second part is the <ContentId> within that <AggregationPoint> that the <ContentSource> will
      provide for.

    * Model vs Components

      In Pax Wicket, you create a <<Model>> of the view, whereas in Wicket itself you create the Components of the view
      directly. This is important to understand, as Pax Wicket needs to delay the creation of Components as long as
      possible, yet have a clear understanding of how things are hanging together.

      The interfaces in Pax Wicket descibes that model, and there are suitable default implementations available to make
      it easy to create a model of the view, and instantiating the view from these model parts.

    * <Page>

      Wicket has a <Page> concept, which is the combination of a Java Page class and a HTML file with the same
      name. Wicket will populate the HTML with missing parts by calling the corresponding Java class. Pax Wicket
      does not change anything in this notion, other than introduction of a <<<PageFactory>>> interface for the
      creation process. In Pax Wicket, each <Page> has a name and belongs to an <Application>. The starting
      page of an <Application>, which is passed to the <<<PaxWicketApplicationFactory>>> must be a so called
      "Bookmarkable" page, which means that it must have a non-argument constructor as well as a constructor
      that accepts <<PageParameter>>s. Only the <<<Class>>> is passed to the <<<PaxWicketApplicationFactory>>>.

    * <PageFactory>

      Pages also need to be modelled, and the main challange reside in bookmarkable pages in Wicket, where Wicket will
      do the instantiation. PageFactory is a model part, which allows the developer control over the instantiation
      of pages, by implementing the <<<getPageClass()>>> and <<<createPage()>>> methods.

    * <<<RootContentAggregator>>>

      The <RootContentAggregator> is an implementation of the <ContentAggregator> suitable for aggregating panels
      and other components as a model for a Wicket page. Unlike the <AbstractContentAggregator>, this implementation
      does not implement  the <ContentSource> interface, and can therefor not be further aggregated in higher level
      <ContentAggregators>.

    * <Wiring>, <Wired>

      <Wiring> is the process of connecting a <ContentSource> to a <ContentAggregator>. The <ContentAggregator> publishes
      an <AggregationPoint> (available from <<<ContentSource.AGGREGATION_POINT>>>) and the <ContentSource> publishes a
      <Destination> (available from <<<ContentSource.DESTINATION>>>). The <Destination> consists of two parts, dot separated,
      as \<<AggregationMatchExpression>\>.\<<ContentMatchExpression>\> where the <ContentSource> will be <wired> to the <ContentAggregator> that
      publishes the <AggregationPoint> that is present in the <Destination>,  and the <ContentAggregator> will lookup
      the <ContentId> from its children during component creation in the request cycle.

